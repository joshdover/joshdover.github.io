<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Programming on Josh Dover</title>
    <link>https://www.joshdover.com/tags/programming/</link>
    <description>Recent content in Programming on Josh Dover</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>© Copyright Josh Dover 2019.</copyright>
    <lastBuildDate>Thu, 18 Apr 2019 18:05:46 -0500</lastBuildDate>
    
	<atom:link href="https://www.joshdover.com/tags/programming/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>When Not to Use Jest Snapshots</title>
      <link>https://www.joshdover.com/when-not-to-use-jest-snapshots/</link>
      <pubDate>Thu, 18 Apr 2019 18:05:46 -0500</pubDate>
      
      <guid>https://www.joshdover.com/when-not-to-use-jest-snapshots/</guid>
      <description>Jest has become the JavaScript community&amp;rsquo;s favorite unit testing tool as of late, largely due to it&amp;rsquo;s fantastic support for testing React components. Although it isn&amp;rsquo;t without it&amp;rsquo;s caveats (it can&amp;rsquo;t be run in a browser), it has many unique features that make testing JavaScript code ergonomic and flexible. In this post, I&amp;rsquo;m going to focus on one of Jest&amp;rsquo;s key features, snapshots, and how to use them effectively.</description>
    </item>
    
    <item>
      <title>The human side of writing good software</title>
      <link>https://www.joshdover.com/the-human-side-of-writing-good-software/</link>
      <pubDate>Sat, 18 Feb 2017 02:38:00 +0000</pubDate>
      
      <guid>https://www.joshdover.com/the-human-side-of-writing-good-software/</guid>
      <description>A maintainable codebase, the holy grail of every software architect’s dreams. For some engineers, it’s something we obsess over: a harmonious construct of easy-to-modify code, a product that can we can remold to the changing requirements of our customers. Unfortunately, the “business reasons” for investing time into writing good software are less clear and often misunderstood.
Flexibility has always come at an expensive cost: time. We’ve found practical, quantifiable ways to justify a focus on maintainability: reduced hours fixing bugs, faster iteration cycles, quicker on-boarding of new developers.</description>
    </item>
    
  </channel>
</rss>